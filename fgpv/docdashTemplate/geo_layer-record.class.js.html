<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>geo/layer-record.class.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="app.module_geo-LayerBlueprint.LayerBlueprint.html">LayerBlueprint</a></li><li><a href="app.module_geo-LayerFileBlueprint.html">LayerFileBlueprint</a><ul class='methods'><li data-type='method'><a href="app.module_geo-LayerFileBlueprint.html#_readFileData">_readFileData</a></li><li data-type='method'><a href="app.module_geo-LayerFileBlueprint.html#generateLayer">generateLayer</a></li></ul></li><li><a href="app.module_geo-LayerServiceBlueprint.LayerServiceBlueprint.html">LayerServiceBlueprint</a></li><li><a href="LayerRecord.html">LayerRecord</a><ul class='methods'><li data-type='method'><a href="LayerRecord.html#createBbox">createBbox</a></li><li data-type='method'><a href="LayerRecord.html#destroyBbox">destroyBbox</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="app.common.module_router.html">router</a></li><li><a href="app.core.module_common.html">common</a></li><li><a href="app.core.module_configService.html">configService</a><ul class='methods'><li data-type='method'><a href="app.core.module_configService.html#~currentLang">currentLang</a></li><li data-type='method'><a href="app.core.module_configService.html#~fileInit">fileInit</a></li><li data-type='method'><a href="app.core.module_configService.html#~getCurrent">getCurrent</a></li><li data-type='method'><a href="app.core.module_configService.html#~initialize">initialize</a></li><li data-type='method'><a href="app.core.module_configService.html#~mergeConfigParts">mergeConfigParts</a></li><li data-type='method'><a href="app.core.module_configService.html#~rcsAddKeys">rcsAddKeys</a></li><li data-type='method'><a href="app.core.module_configService.html#~rcsInit">rcsInit</a></li><li data-type='method'><a href="app.core.module_configService.html#~rcsLoad">rcsLoad</a></li><li data-type='method'><a href="app.core.module_configService.html#~ready">ready</a></li></ul></li><li><a href="app.layout.module_layoutService.html">layoutService</a></li><li><a href="app.layout.module_rvShell.html">rvShell</a></li><li><a href="app.layout.module_storageService.html">storageService</a></li><li><a href="app.module_common.html">common</a></li><li><a href="app.module_geo.html">geo</a><ul class='methods'><li data-type='method'><a href="app.module_geo.html#.transformXML">transformXML</a></li></ul></li><li><a href="app.ui.common.module_stepper.html">stepper</a></li><li><a href="app.ui.module_appbar.html">appbar</a></li><li><a href="app.ui.module_basemap.html">basemap</a></li><li><a href="app.ui.module_common.html">common</a></li><li><a href="app.ui.module_details.html">details</a></li><li><a href="app.ui.module_filters.html">filters</a></li><li><a href="app.ui.module_help.html">help</a></li><li><a href="app.ui.module_loader.html">loader</a></li><li><a href="app.ui.module_mapnav.html">mapnav</a></li><li><a href="app.ui.module_metadata.html">metadata</a></li><li><a href="app.ui.module_panels.html">panels</a></li><li><a href="app.ui.module_settings.html">settings</a></li><li><a href="app.ui.module_sidenav.html">sidenav</a></li><li><a href="app.ui.module_toc.html">toc</a></li><li><a href="app.ui.module_toolbox.html">toolbox</a></li><li><a href="material.components.module_menuBar.html">menuBar</a></li><li><a href="module-ap.html">ap</a></li></ul><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="app.common.html">common</a></li><li><a href="app.core.html">core</a><ul class='methods'><li data-type='method'><a href="app.core.html#.apiBlock">apiBlock</a></li><li data-type='method'><a href="app.core.html#.configBlock">configBlock</a></li><li data-type='method'><a href="app.core.html#.runBlock">runBlock</a></li><li data-type='method'><a href="app.core.html#.seed">seed</a></li><li data-type='method'><a href="app.core.html#~configureIconsets">configureIconsets</a></li><li data-type='method'><a href="app.core.html#~configureTheme">configureTheme</a></li><li data-type='method'><a href="app.core.html#~configureTranslations">configureTranslations</a></li><li data-type='method'><a href="app.core.html#~loadRcsLayers">loadRcsLayers</a></li><li data-type='method'><a href="app.core.html#~setLanguage">setLanguage</a></li></ul></li><li><a href="app.layout.html">layout</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-getting_started.html">Getting Started</a></li><li><a href="tutorial-gulp-i18n-csv.html">Translation Plugin</a></li></ul><h3>Global</h3><ul><li><a href="global.html#RV">RV</a></li><li><a href="global.html#versionCheck">versionCheck</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">geo/layer-record.class.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(() => {
    angular.module('app.geo').factory('LayerRecordFactory', LayerRecordFactory);

    function LayerRecordFactory(Geo, gapiService, $q) {
        const gapi = () => gapiService.gapi;

        class LayerRecord {
            get layerClass () { throw new Error('This should be overridden in subclasses'); }
            get config () { return this.initialConfig; } // TODO: add a live config reference if needed
            get legendEntry () { return this._legendEntry; } // legend entry class corresponding to those defined in legend entry service
            set legendEntry (value) { this._legendEntry = value; }
            get bbox () { return this._bbox; } // bounding box layer
            get state () { return this._state; }
            get layerId () { return this.config.id; }
            get _layerPassthroughBindings () { return ['setOpacity', 'setVisibility']; } // TODO when jshint parses instance fields properly we can change this from a property to a field
            get _layerPassthroughProperties () { return ['visibleAtMapScale', 'visible', 'spatialReference']; } // TODO when jshint parses instance fields properly we can change this from a property to a field

            /**
             * Generate a bounding box for the layer on the given map.
             */
            createBbox (map) {
                if (this._bbox) {
                    throw new Error('Bbox is already setup');
                }
                this._bbox = gapi().layer.bbox.makeBoundingBox(`bbox_${this._layer.id}`,
                                                               this._layer.fullExtent,
                                                               map.extent.spatialReference);
                map.addLayer(this._bbox);
            }

            /**
             * Destroy bounding box
             */
            destroyBbox (map) {
                map.removeLayer(this._bbox);
                this._bbox = undefined;
            }

            bindEvents (layer) {
                gapi().events.wrapEvents(layer, {
                    // wrapping the function calls to keep `this` bound correctly
                    load: () => this.onLoad(),
                    error: e => this.onError(e),
                    'update-start': () => this.onUpdateStart(),
                    'update-end': () => this.onUpdateEnd()
                });
            }

            constructLayer () {
                this._layer = this.layerClass(this.config.url, this.makeLayerConfig());
                this.bindEvents(this._layer);
                return this._layer;
            }

            _stateChange (newState) {
                this._state = newState;
                console.log(`State change for ${this.layerId} to ${newState}`);
                // if we don't copy the array we could be looping on an array
                // that is being modified as it is being read
                this._stateListeners.slice(0).forEach(l => l(this._state));
            }

            addStateListener (listenerCallback) {
                this._stateListeners.push(listenerCallback);
                return listenerCallback;
            }

            removeStateListener (listenerCallback) {
                const idx = this._stateListeners.indexOf(listenerCallback);
                if (idx &lt; 0) {
                    throw new Error('Attempting to remove a listener which is not registered.');
                }
                this._stateListeners.splice(idx, 1);
            }

            onLoad () {
                if (this.legendEntry &amp;&amp; this.legendEntry.removed) { return; }
                console.info(`Layer loaded: ${this._layer.id}`);
                let lookupPromise = Promise.resolve();
                if (this._epsgLookup) {
                    const check = gapi().proj.checkProj(this.spatialReference, this._epsgLookup);
                    if (check.lookupPromise) {
                        lookupPromise = check.lookupPromise;
                    }
                }
                lookupPromise.then(() => this._stateChange(Geo.Layer.States.LOADING));
            }

            onError (e) {
                console.warn(`Layer error: ${e}`);
                console.warn(e);
                this._stateChange(Geo.Layer.States.ERROR);
            }

            onUpdateStart () {
                this._stateChange(Geo.Layer.States.REFRESH);
            }

            onUpdateEnd () {
                this._stateChange(Geo.Layer.States.LOADED);
            }

            makeLayerConfig () {
                return { id: this.config.id };
            }

            /**
             * Create a layer record with the appropriate geoApi layer type.  Layer config
             * should be fully merged with all layer options defined (i.e. this constructor
             * will not apply any defaults).
             * @param {Object} config layer config values
             * @param {Object} esriLayer an optional pre-constructed layer
             * @param {Function} epsgLookup an optional lookup function for EPSG codes (see geoService for signature)
             */
            constructor (config, esriLayer, epsgLookup) {
                this.initialConfig = config;
                this._stateListeners = [];
                this._epsgLookup = epsgLookup;
                this._layerPassthroughBindings.forEach(bindingName =>
                    this[bindingName] = (...args) => this._layer[bindingName](...args));
                this._layerPassthroughProperties.forEach(propName => {
                    const descriptor = {
                        enumerable: true,
                        get: () => this._layer[propName]
                    };
                    Object.defineProperty(this, propName, descriptor);
                });
                if (esriLayer) {
                    this.constructLayer = () => { throw new Error('Cannot construct pre-made layers'); };
                    this._layer = esriLayer;
                    this.bindEvents(this._layer);
                    this.state = Geo.Layer.States.LOADED;
                } else {
                    this.constructLayer(config);
                    this.state = Geo.Layer.States.NEW;
                }

                // NOTE layer registry is responsible for adding the layer to the map
                // this avoids LayerRecord having an explicit dependency on the map object
            }

        }

        class AttrRecord extends LayerRecord {
            get attributeBundle () { return this._attributeBundle; }
            // FIXME clickTolerance is not specific to AttrRecord but rather Feature and Dynamic
            get clickTolerance () { return this.config.tolerance; }

            constructor (config, esriLayer, epsgLookup) {
                super(config, esriLayer, epsgLookup);
                this._formattedAttributes = {};
            }

            onLoad () {
                this._attributeBundle = gapi().attribs.loadLayerAttribs(this._layer);
                super.onLoad();
            }

            /**
             * Formats raw attributes to the form consumed by the datatable
             * @param  {Object} attributes raw attribute data returned from geoapi
             * @return {Object} layerData  layer data returned from geoApi
             * @return {Object}               formatted attribute data { data: Array, columns: Array, fields: Array, oidField: String, oidIndex: Object}
             */
            formatAttributes (attributes, layerData) {
                // create columns array consumable by datables
                const fieldNameArray = [];
                const columns = layerData.fields
                    .filter(field =>
                        // assuming there is at least one attribute - empty attribute budnle promises should be rejected, so it never even gets this far
                        // filter out fields where there is no corresponding attribute data
                        attributes.features[0].attributes.hasOwnProperty(field.name))
                    .map(field => {
                        // check if date type; append key to fieldNameArray if so
                        if (field.type === 'esriFieldTypeDate') {
                            fieldNameArray.push(field.name);
                        }
                        return {
                            data: field.name,
                            title: field.alias || field.name
                        };
                    });

                // extract attributes to an array consumable by datatables
                const rows = attributes.features.map(feature => feature.attributes);

                // convert each date cell to ISO format
                fieldNameArray.forEach(fieldName => {
                    rows.forEach(row => {
                        const date = new Date(row[fieldName]);
                        row[fieldName] = date.toISOString().substring(0, 10);
                    });
                });

                return {
                    columns,
                    rows,
                    fields: layerData.fields, // keep fields for reference ...
                    oidField: layerData.oidField, // ... keep a reference to id field ...
                    oidIndex: attributes.oidIndex, // ... and keep id mapping array
                    renderer: layerData.renderer
                };
            }

            /**
             * Retrieves attributes from a layer for a specified feature index
             * @param  {Number} featureIdx feature id on the service endpoint
             * @return {Promise}            promise resolving with formatted attributes to be consumed by the datagrid and esri feature identify
             */
            getAttributes (featureIdx) {
                if (this._formattedAttributes.hasOwnProperty(featureIdx)) {
                    return this._formattedAttributes[featureIdx];
                }

                const layerPackage = this._attributeBundle[featureIdx];
                const attributePromise = $q.all([layerPackage.getAttribs(), layerPackage.layerData])
                    .then(([attributes, layerData]) => this.formatAttributes(attributes, layerData));
                return (this._formattedAttributes[featureIdx] = attributePromise);
            }

        }

        class ImageRecord extends LayerRecord {
            get layerClass () { return gapi().layer.ArcGISImageServiceLayer; }
        }

        class DynamicRecord extends AttrRecord {
            get _layerPassthroughBindings () {
                return ['setOpacity', 'setVisibility', 'setVisibleLayers', 'setLayerDrawingOptions'];
            }
            get _layerPassthroughProperties () {
                return ['visibleAtMapScale', 'visible', 'spatialReference', 'layerInfos', 'supportsDynamicLayers'];
            }
            get layerClass () { return gapi().layer.ArcGISDynamicMapServiceLayer; }
        }

        class TileRecord extends LayerRecord {
            get layerClass () { return gapi().layer.TileLayer; }
        }

        class WmsRecord extends LayerRecord {
            get layerClass () { return gapi().layer.ogc.WmsLayer; }

            makeLayerConfig () {
                const cfg = super.makeLayerConfig();
                cfg.visibleLayers = this.config.layerEntries.map(le => le.id);
                return cfg;
            }
        }

        class FeatureRecord extends AttrRecord {
            get layerClass () { return gapi().layer.FeatureLayer; }

            makeLayerConfig () {
                const cfg = super.makeLayerConfig();
                cfg.mode = this.config.options.snapshot.value ? this.layerClass.MODE_SNAPSHOT
                                                              : this.layerClass.MODE_ONDEMAND;
                return cfg;
            }
        }

        function makeServiceRecord(config, epsgLookup) {
            const types = Geo.Layer.Types;
            const typeToClass = {
                [types.ESRI_TILE]: TileRecord,
                [types.ESRI_FEATURE]: FeatureRecord,
                [types.ESRI_IMAGE]: ImageRecord,
                [types.ESRI_DYNAMIC]: DynamicRecord,
                [types.OGC_WMS]: WmsRecord
            };
            return new typeToClass[config.layerType](config, undefined, epsgLookup);
        }

        function makeFileRecord(config, layer) {
            return new FeatureRecord(config, layer);
        }

        return { makeServiceRecord, makeFileRecord };
    }
})();
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sun Jun 19 2016 14:13:40 GMT+0000 (UTC) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
