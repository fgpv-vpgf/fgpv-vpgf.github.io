<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/config.service.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="app.module_geo-LayerBlueprint.LayerBlueprint.html">LayerBlueprint</a></li><li><a href="app.module_geo-LayerFileBlueprint.html">LayerFileBlueprint</a><ul class='methods'><li data-type='method'><a href="app.module_geo-LayerFileBlueprint.html#_readFileData">_readFileData</a></li><li data-type='method'><a href="app.module_geo-LayerFileBlueprint.html#generateLayer">generateLayer</a></li><li data-type='method'><a href="app.module_geo-LayerFileBlueprint.html#validate">validate</a></li></ul></li><li><a href="app.module_geo-LayerServiceBlueprint.LayerServiceBlueprint.html">LayerServiceBlueprint</a></li><li><a href="LayerRecord.html">LayerRecord</a><ul class='methods'><li data-type='method'><a href="LayerRecord.html#.parseData">parseData</a></li><li data-type='method'><a href="LayerRecord.html#createBbox">createBbox</a></li><li data-type='method'><a href="LayerRecord.html#destroyBbox">destroyBbox</a></li><li data-type='method'><a href="LayerRecord.html#makeLayerBookmark">makeLayerBookmark</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="app.common.module_displayManager.html">app.common.displayManager</a><ul class='methods'><li data-type='method'><a href="app.common.module_displayManager.html#~clearDisplayPanel">clearDisplayPanel</a></li><li data-type='method'><a href="app.common.module_displayManager.html#~setDisplay">setDisplay</a></li><li data-type='method'><a href="app.common.module_displayManager.html#~toggleDisplayPanel">toggleDisplayPanel</a></li></ul></li><li><a href="app.common.module_stateManager.html">app.common.stateManager</a><ul class='methods'><li data-type='method'><a href="app.common.module_stateManager.html#~addState">addState</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~callback">callback</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~closePanel">closePanel</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~closePanelFromHistory">closePanelFromHistory</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~getChildren">getChildren</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~getItem">getItem</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~getParent">getParent</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~modifyHistory">modifyHistory</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~onCloseCallback">onCloseCallback</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~openPanel">openPanel</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~previousFocus">previousFocus</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~runCloseCallback">runCloseCallback</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~setActive">setActive</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~setFocusElement">setFocusElement</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~setItemProperty">setItemProperty</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~setMorph">setMorph</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~setPanelFocus">setPanelFocus</a></li><li data-type='method'><a href="app.common.module_stateManager.html#~togglePanel">togglePanel</a></li></ul></li><li><a href="app.core.module_common.html">app.core.common</a></li><li><a href="app.core.module_configService.html">app.core.configService</a><ul class='methods'><li data-type='method'><a href="app.core.module_configService.html#~currentLang">currentLang</a></li><li data-type='method'><a href="app.core.module_configService.html#~fileInit">fileInit</a></li><li data-type='method'><a href="app.core.module_configService.html#~getCurrent">getCurrent</a></li><li data-type='method'><a href="app.core.module_configService.html#~initialize">initialize</a></li><li data-type='method'><a href="app.core.module_configService.html#~mergeConfigParts">mergeConfigParts</a></li><li data-type='method'><a href="app.core.module_configService.html#~rcsAddKeys">rcsAddKeys</a></li><li data-type='method'><a href="app.core.module_configService.html#~rcsInit">rcsInit</a></li><li data-type='method'><a href="app.core.module_configService.html#~rcsLoad">rcsLoad</a></li><li data-type='method'><a href="app.core.module_configService.html#~ready">ready</a></li></ul></li><li><a href="app.geo.module_metadataService.html">app.geo.metadataService</a><ul class='methods'><li data-type='method'><a href="app.geo.module_metadataService.html#.transformXml">transformXml</a></li></ul></li><li><a href="app.layout.module_layoutService.html">app.layout.layoutService</a></li><li><a href="app.layout.module_rvShell.html">app.layout.rvShell</a></li><li><a href="app.layout.module_storageService.html">app.layout.storageService</a></li><li><a href="app.module_common.html">app.common</a></li><li><a href="app.module_core.html">app.core</a></li><li><a href="app.module_geo.html">app.geo</a></li><li><a href="app.ui.common.module_stepper.html">app.ui.common.stepper</a></li><li><a href="app.ui.module_appbar.html">app.ui.appbar</a></li><li><a href="app.ui.module_basemap.html">app.ui.basemap</a></li><li><a href="app.ui.module_common.html">app.ui.common</a></li><li><a href="app.ui.module_details.html">app.ui.details</a></li><li><a href="app.ui.module_filters.html">app.ui.filters</a></li><li><a href="app.ui.module_help.html">app.ui.help</a></li><li><a href="app.ui.module_loader.html">app.ui.loader</a></li><li><a href="app.ui.module_mapnav.html">app.ui.mapnav</a></li><li><a href="app.ui.module_metadata.html">app.ui.metadata</a></li><li><a href="app.ui.module_panels.html">app.ui.panels</a></li><li><a href="app.ui.module_rvTocEntryControl.html">app.ui.rvTocEntryControl</a></li><li><a href="app.ui.module_settings.html">app.ui.settings</a></li><li><a href="app.ui.module_sidenav.html">app.ui.sidenav</a></li><li><a href="app.ui.module_toc.html">app.ui.toc</a></li><li><a href="app.ui.module_tocService.html">app.ui.tocService</a></li><li><a href="app.ui.module_toolbox.html">app.ui.toolbox</a></li><li><a href="material.components.menuBar.module_mdMenuItemDirectiveDecorator.html">material.components.menuBar.mdMenuItemDirectiveDecorator</a><ul class='methods'><li data-type='method'><a href="material.components.menuBar.module_mdMenuItemDirectiveDecorator.html#~decorateCompile">decorateCompile</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="app.common.html">app.common</a></li><li><a href="app.core.html">app.core</a><ul class='methods'><li data-type='method'><a href="app.core.html#.apiBlock">apiBlock</a></li><li data-type='method'><a href="app.core.html#.configBlock">configBlock</a></li><li data-type='method'><a href="app.core.html#.runBlock">runBlock</a></li><li data-type='method'><a href="app.core.html#.seed">seed</a></li><li data-type='method'><a href="app.core.html#~configureIconsets">configureIconsets</a></li><li data-type='method'><a href="app.core.html#~configureTheme">configureTheme</a></li><li data-type='method'><a href="app.core.html#~configureTranslations">configureTranslations</a></li><li data-type='method'><a href="app.core.html#~loadRcsLayers">loadRcsLayers</a></li><li data-type='method'><a href="app.core.html#~setLanguage">setLanguage</a></li></ul></li><li><a href="app.geo.html">app.geo</a></li><li><a href="app.layout.html">app.layout</a></li><li><a href="app.ui.html">app.ui</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-getting_started.html">Getting Started</a></li><li><a href="tutorial-gulp-i18n-csv.html">Translation Plugin</a></li></ul><h3>Global</h3><ul><li><a href="global.html#RV">RV</a></li><li><a href="global.html#versionCheck">versionCheck</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">core/config.service.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(() => {
    'use strict';

    /**
     * @module configService
     * @memberof app.core
     * @requires $q
     * @requires $rootElement
     * @requires $timeout
     * @requires $http
     * @requires configDefaults
     * @description
     *
     * The `configService` is responsible for loading and parsing the supplied configuration.
     *
     * Config file is either specified inline, by a url or is referencing a global variable:
     * ```html
     * &lt;div rv-map rv-cfg='{"layout": { "title": "Granpa"}}'>&lt;/div>
     * ```
     * ```html
     * &lt;div rv-map rv-cfg="config.en.json">&lt;/div>
     * ```
     * ```html
     * &lt;div rv-map rv-cfg="configOpts">&lt;/div>
     * &lt;script>configOpts = {}&lt;/script>
     * ```
     * The main core run block (core.run.js) kicks in the initialization process by calling initialize on the `configService`. `configService` is responsible for parsing (inline) or loading (url) of the config. This service preserves the configuration in its pristine state (after applying all the defaults) - it will not be modified.
     * After the main config service retrieved the configuration, all other services are initialized. Until then, the application is covered by a loading overlay to hide unstyled content.
     *
     * Config service body returns the service object with the following:
     * - data: config data
     * - initialize: initialize function; call from core.run
     * - ready: checks if the service is ready to use
     *
     */
    angular
        .module('app.core')
        .factory('configService', configService);

    function configService($q, $rootElement, $timeout, $http, $translate, $mdToast) {
        let initializePromise;
        let isInitialized = false;

        const service = {
            data: {},
            getCurrent,
            currentLang,
            initialize,
            ready,
            rcsAddKeys,
            rcsUrl: ''
        };

        const partials = {}; // partial config promises, one array per language entry
        const configFile = {};

        return service;

        /***************/

        /**
         * Initializes `configService` by fetching and parsing `config` object.
         * @function initialize
         */
        function initialize() {
            if (initializePromise) {
                return initializePromise;
            }

            // store the promise and return it on all future calls; this way initialize can be called one time only
            initializePromise = $q((fulfill, reject) => {
                const configAttr = $rootElement.attr('rv-config');
                const langAttr = $rootElement.attr('rv-langs');
                const svcAttr = $rootElement.attr('rv-service-endpoint');
                const keysAttr = $rootElement.attr('rv-keys');
                let langs;

                // This function can only be called once.
                if (isInitialized) {
                    return fulfill();
                }

                // check if config attribute exist
                if (configAttr) {
                    if (langAttr) {
                        try {
                            langs = angular.fromJson(langAttr);
                        } catch (e) {
                            console.warn('Could not parse langs, defaulting to en-CA and fr-CA');

                            // TODO: better way to handle when no languages are specified?
                            langs = ['en-CA', 'fr-CA'];
                        }
                    } else {
                        langs = ['en-CA', 'fr-CA'];
                    }

                    // set the language right away and not wait the initialization to be fullfilled
                    $translate.use(langs[0]);

                    langs.forEach(lang => partials[lang] = []);

                    if (svcAttr) {
                        service.rcsUrl = svcAttr;  // store for future RCS loads
                        rcsInit(svcAttr, keysAttr, langs);
                    }

                    // start loading every config file
                    fileInit(configAttr, langs);

                    langs.forEach(lang => {
                        service.data[lang] = $q.all(partials[lang])
                            .then(configParts => {
                                // generate a blank config, merge in all the stuff we have loaded
                                // the merged config is our promise result for all to use
                                const newConfig = {
                                    layers: []
                                };
                                mergeConfigParts(newConfig, configParts);
                                return newConfig;
                            })
                            .catch(() => {
                                // TODO: possibly retry rcsLoad?
                                console.warn('RCS failed, starting app with file-only config.');
                                const toast = $mdToast.simple()
                                    .textContent($translate.instant('config.service.rcs.error'))
                                    .action($translate.instant('config.service.rcs.action'))
                                    .highlightAction(true)
                                    .hideDelay(0)
                                    .position('bottom rv-flex-global');
                                $mdToast.show(toast);
                                return configFile[lang];
                            });
                    });

                    // initialize the app once the default language's config is loaded
                    // FIXME: replace with getCurrent().then / service.data[Default language] if we have a way to check
                    service.data[langs[0]]
                        .then(() => {
                            isInitialized = true;
                            fulfill(service.data[langs[0]]);
                        })
                        .catch(error => {
                            reject(error);
                            console.error(error);
                        });
                }
            });

            return initializePromise;
        }

        /**
         * Config initialization block for file-based configs
         * @function fileInit
         * @param {string}  configAttr  the file path tied to the config attribute
         * @param {array}   langs       array of languages which have configs
         */
        function fileInit(configAttr, langs) {
            langs.forEach(lang => {
                // try to load config file
                const p = $http.get(configAttr.replace('${lang}', lang))
                    .then(xhr => xhr.data);
                partials[lang].push(p);
                configFile[lang] = p;
            });
        }

        /**
         * Returns the currently language.
         * @function currentLang
         * @return {String} the current language string
         */
        function currentLang() {
            return ($translate.proposedLanguage() || $translate.use());
        }

        /**
         * Returns the currently used config. Language is determined by asking $translate.
         * @function getCurrent
         * @return {Promise}     The config promise object tied to the current language resolving with that config
         */
        function getCurrent() {
            return service.data[currentLang()];
        }

        /**
         * Modifies a config by merging in separate config chunks.
         * @function mergeConfigParts
         * @private
         * @param {object} targetConfig  the config object to merge things into. Object will be modified
         * @param {array}   configParts  array of config chunks to merge
         */
        function mergeConfigParts(targetConfig, configParts) {
            configParts.forEach(part => {
                Object.entries(part).forEach(([key, value]) => {
                    // if this section is an array just concat, e.g. layers, basemaps
                    // otherwise merge into existing section
                    if (Array.isArray(targetConfig[key])) {
                        targetConfig[key] = targetConfig[key].concat(value);
                    } else {
                        targetConfig[key] = value;
                    }
                });
            });
        }

        /**
         * Config initialization block for rcs retrieved config snippets
         * @function rcsInit
         * @private
         * @param {string}  svcAttr     the server path tied to the config attribute
         * @param {string}  keysAttr    list of keys marking which layers to retrieve
         * @param {array}   langs       array of languages which have configs
         */
        function rcsInit(svcAttr, keysAttr, langs) {
            let keys;
            if (keysAttr) {
                try {
                    keys = angular.fromJson(keysAttr);
                } catch (e) {
                    console.error(e);
                    console.error('RCS key retrieval failed');
                }

                const rcsData = rcsLoad(svcAttr, keys, langs);
                langs.forEach(lang => {
                    // add the rcs data promises to our partials set
                    partials[lang].push(rcsData[lang]);
                });
            } else {
                console.warn('RCS endpoint set but no keys were specified');
            }
        }

        /**
         * Add RCS config layers to configuration after startup has finished
         * @function rcsAddKeys
         * @param {Array}  keys    list of keys marking which layers to retrieve
         * @return {Promise} promise of full config nodes for newly added layers
         */
        function rcsAddKeys(keys) {

            // strip languages out of data object.
            const langs =  Object.keys(service.data);

            // get array of promises containing RCS bundles per language
            const rcsDataSet = rcsLoad(service.rcsUrl, keys, langs);

            return $q(resolve => {
                const currLang = currentLang();
                let newIds;

                langs.forEach(lang => {
                    // wait for rcs data to finish loading
                    rcsDataSet[lang].then(rcsConfig => {
                        if (lang === currLang) {
                            // store list of layer ids, so we can identify new items in the config later
                            newIds = rcsConfig.layers.map(layer => layer.id);
                        }

                        service.data[lang].then(fullConfig => {
                            // call the merge into config, passing result and targeting innards of config service (all languages)
                            // make rcs value an array, as it will be a singleton with all things mooshed into .layers
                            mergeConfigParts(fullConfig, [rcsConfig]);

                            if (lang === currLang) {
                                // pull fully populated layer config nodes out the main config
                                const newConfigs = fullConfig.layers.filter(layerConfig => {
                                    return newIds.indexOf(layerConfig.id) > -1;
                                });

                                // return the new configs to the caller
                                resolve(newConfigs);
                            }
                        });
                    });
                });

            });
        }

        /**
         * Retrieve a set of config snippets from RCS
         * @function rcsLoad
         * @param {string}  svcPath     the server path of RCS
         * @param {array}  keys    array of keys marking which layers to retrieve
         * @param {array}   langs       array of languages which have configs
         * @return {Object}  mapping of language to promise that resolves in RCS config object
         */
        function rcsLoad(svcPath, keys, langs) {
            const endpoint = svcPath.endsWith('/') ? svcPath : svcPath + '/';
            const results = {};

            langs.forEach(lang => {
                // hit RCS for each language

                // remove country code
                let rcsLang = lang.split('-')[0];

                // rcs can only handle english and french
                // TODO: update if RCS supports more languages
                // TODO: make this language array a configuration option
                if (['en', 'fr'].indexOf(rcsLang) === -1) {
                    rcsLang = 'en';
                }

                const p = $http.get(`${endpoint}v2/docs/${rcsLang}/${keys.join(',')}`)
                    .then(resp => {
                        const result = { layers: [] };

                        // there is an array of layer configs in resp.data.
                        // moosh them into one single layer array on the result
                        // FIXME may want to consider a more flexible approach than just assuming RCS
                        // always returns nothing but a single layer per key.  Being able to inject any
                        // part of the config via would be more robust
                        resp.data.forEach(layerEntry => {
                            // if the key is wrong rcs will return null
                            if (layerEntry) {
                                result.layers.push(layerEntry.layers[0]);
                            }
                        });

                        return result;
                    });
                results[lang] = p;
            });

            return results;
        }

        /**
         * Checks if the service is ready to use.
         * @function ready
         * @param  {Promise|Array} nextPromises optional promises to be resolved before returning
         * @return {Promise}              promise to be resolved on config service initialization
         */
        function ready(nextPromises) {
            return initializePromise
                .then(() => {
                    console.log('Ready promise resolved.');
                    return $q.all(nextPromises);
                })
                .catch(() => {
                    console.log('"ready" function failed');
                });
        }
    }
})();
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Jul 09 2016 18:43:25 GMT+0000 (UTC) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
